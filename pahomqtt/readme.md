#背景
本示例程序使用`paho`客户端实现了消息的生产者与消费者。MQTT的服务端broker采用mosquitto实现，其它的实现还有ActiveMQ。
主要验证了当订阅者由于网络原因与broker断开后，当再次连接上时，是否还能够收到生产者在断开期间发送的消息，经验证，通过设置`cleanSession`与`clientId`两者配合可达到预期效果，但前提条件是生产者发送消息的QOS需要为1或2级别。
#mosquitto安装
安装请参见[Linux下安装mosquitto](https://blog.csdn.net/mao_2110901055/article/details/78975098)
#MQTT理解
MQTT是一种遥测传输协议，遥测可以理解为遥感测量，遥感通指的是传感器。它提供了发布/订阅的模型，意为一个消息生产者，多个消息消费者。它更为轻量、简单、易于使用，针对受限的环境（带宽低、网络延时不稳定、网络通信不稳定）而生的，小型传输，开销小（固定长度的头部2个字节）；它使用TCP/IP进行网络连接，对负载内容不关心。
##消息传递模型
消息传递模型其实也是指MQTT中的QOS服务质量。
 - 最多一次，是指生产者只发送一次消息，不关注该消息由于网络原因等问题，该消息是否己被消费者接收到，这样可能出现消息丢失的情况；
 - 至少一次，至少一次的本质策略就是重试、重试、再重试的过程，在分布式架构中，网络本身是不可靠的，站生产者的角度，一定要接收到消费者的接收确认后，才丢弃该消息表明该消息己被接收消费掉，这样可能出现消息重复消费的情况；
 - 恰好一次，表示消息恰好只被消费一次，这也是对控制要求最高的级别，需要站在生产者与消费者两方的角度考虑，均有消息确认的操作，站在生产者角度有两点或者两个过程需要考虑，一点是消息是否己被消费者接收，体现在接收到PUBREC消息，另一点是消息是否己被消费者正确消费，体现在生产者发送PUBREL后等待PUBCOMP的过程，当生产者发送PUBREL后，该消息就不能被生产者再次发送。
PUBREC （publish recieve）指明己接收到消息
PUBREL （publish release）指明发送端准备释放
PUBCOMP（publish completed）指明接收端己完成
为什么要关注第二点等待消费者的消费确认呢？因为消费者接收到了不一定就消费掉了，所以需要第二个过程。

##主题通配符
 - `/`主题层级分隔符，意思为每个层级都以它为分隔；
 - `#`多层级通配符，示例`/application/#`意思为application本级与它下面的所有层级均能够匹配；
 - `+`单层级通配符
 - 以`$`开头的主题，`$SYS/`被广泛用作包含服务器特定信息或控制接口的主题的前缀，服务端不能将通配符`#/+`配置到此类主题。

通配符的好处在哪里？

1，生产者可以有多个级别的主题，消费者可以以一个通配的形式，不用过多关注具体的主题；

2，从配置修改角度来说，如果消费者主题进行了微调，修改、增加或删除了，在消费者这侧可以不用变化其配置。